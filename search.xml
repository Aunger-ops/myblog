<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>🕯️🕯️🕯️🕯️</title>
    <url>/passages/15/</url>
    <content><![CDATA[<!-- build time:Sat Apr 04 2020 13:20:20 GMT+0800 (GMT+08:00) --><p>缅怀同胞，铭记英雄。</p><a id="more"></a><center>**缅怀同胞，铭记英雄。**</center>![共同缅怀抗“疫”英烈](https://cdn.jsdelivr.net/gh/Aunger-ops/myblog@latest/images/2020/15/1.jpg "共同缅怀抗“疫”英烈")<!-- rebuild by neat -->]]></content>
  </entry>
  <entry>
    <title>巧用Tencent官方模块进行文章排版</title>
    <url>/passages/14/</url>
    <content><![CDATA[<!-- build time:Sat Apr 04 2020 13:08:48 GMT+0800 (GMT+08:00) --><p>学习TGideas的经验时偶然发现了腾讯官方用于文章排版的一个小工具，且应用十分简单，只需要增加一段代码即可。这个插件不仅可以对冗余样式、缩进的文章代码进行优化，并且还支持背景颜色的设置。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习TGideas的经验时偶然发现了腾讯官方用于文章排版优化的一个小工具，且应用十分简单，只需要增加一段代码即可。这个插件不仅可以对冗余样式、缩进的文章代码进行优化，并且还支持背景颜色的设置。可以说是非常实用。</p><h2 id="模块功能设置"><a href="#模块功能设置" class="headerlink" title="模块功能设置"></a>模块功能设置</h2><p><strong>参数el</strong></p><p>类型：<code>String | HTMLElement</code>，例如：<code>.detail-content</code></p><p>详情：提供一个在页面上包裹详情内容信息的 DOM 元素或者类名。</p><p><strong>参数options</strong></p><p>类型：<code>Object</code></p><p>详情：相关优化的方法的参数</p><p>具体参考如下：</p><table><thead><tr><th>options设置项</th><th>类型</th><th>详情</th></tr></thead><tbody><tr><td>isClear</td><td>Boolean</td><td>是否清除空行</td></tr><tr><td>isDelete</td><td>Boolean</td><td>是否冗余样式</td></tr><tr><td>styleArr</td><td>Array</td><td>需要去除的冗余样式，默认去除冗余的字体和字号 [‘font-family’,’font-size’]</td></tr><tr><td>color</td><td>Boolean</td><td>是否对文章进行颜色处理，优化文章中设置的文字颜色与页面背景颜色之间的对比度达到符合WCAG2.0 AA要求。</td></tr><tr><td>process</td><td>Boolean</td><td>是否对文章进行进度条处理，展现文章的阅读进度，默认出现条形占比条</td></tr><tr><td>isProcessBar</td><td>Boolen</td><td>是否显示条形占比条，默认true</td></tr><tr><td>processDir</td><td>String</td><td>进度条所处位置，默认’right’,可选(‘left’‘right’‘top’‘bottom’)</td></tr><tr><td>isProcessCont</td><td>Boolean</td><td>是否出现目录进度条，默认false</td></tr><tr><td>previewPic</td><td>Boolean</td><td>是否对文章图片进行可全屏缩放预览处理</td></tr><tr><td>imageSet</td><td>Boolean</td><td>是否对段落内只有一个图片进行居中和宽100%处理，并加上类detail-pic</td></tr><tr><td>isDeleteRetract</td><td>Boolean</td><td>是否对（段落文字）下的段落取消缩进</td></tr></tbody></table><h2 id="模块方法"><a href="#模块方法" class="headerlink" title="模块方法"></a>模块方法</h2><ol><li><p>refresh()<br>详情：正文内容更新后进行刷新，重新刷新进度条</p></li><li><p>setDetailColor({bgElem:’改变背景色的dom元素或类名或ID’})</p></li></ol><p><strong>详情</strong>：对指定dom下的背景色对文章进行颜色替换已符合对比度标准，增强文章的可读性，bgElem默认为body</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>具体参照Tencent官方的范例，本文不再做过多介绍</p><ol><li>原样与优化后对比：<a href="https://tgideas.qq.com/doc/demo/component/tgdetail/demo3.shtml" target="_blank" rel="noopener" title="点击查看demo">点击查看demo</a></li><li>浅色背景与深色背景对比：<a href="https://tgideas.qq.com/doc/demo/component/tgdetail/demo4.shtml" target="_blank" rel="noopener" title="点击查看demo">点击查看demo</a></li><li>点击切换白天黑夜模式：<a href="https://tgideas.qq.com/doc/demo/component/tgdetail/demo5.shtml" target="_blank" rel="noopener" title="点击查看demo">点击查看demo</a></li></ol><h2 id="JS代码"><a href="#JS代码" class="headerlink" title="JS代码"></a>JS代码</h2><p>在所需文章格式化页<code>&lt;body&gt;</code>处插入一下JS代码即可完成排版功能。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入文章排版功能模块JS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//ossweb-img.qq.com/images/js/tgTypeFiles/js/tgDetail-v3.js"</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 功能参数设置</span></span></span><br><span class="line"><span class="actionscript">  (<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> dd=<span class="keyword">new</span> TGDetail(<span class="string">'.detail-content'</span>, &#123;</span></span><br><span class="line"><span class="actionscript">      isProcessCont:<span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">      isClear:<span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">      isDelete:<span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">      styleArr:<span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">      color:<span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">      process:<span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">      isProcessBar:<span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">      processDir:<span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">      isProcessCont:<span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">      previewPic:<span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">      imageSet:<span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">      isDeleteRetract:<span class="literal">true</span>,</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;)();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>转载自：<a href="https://tgideas.qq.com/" target="_blank" rel="noopener" title="TGideas">TGideas</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB前端安全手册</title>
    <url>/passages/13/</url>
    <content><![CDATA[<!-- build time:Sat Apr 04 2020 13:08:48 GMT+0800 (GMT+08:00) --><p>安全问题无小事，web前端是Web安全的第一道屏障，本篇结合真实案例及相关资料，汇总整理了前端方面的安全防护措施,请大家一定要重视。如有遇到新的问题，欢迎反馈。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>安全问题无小事，web前端是Web安全的第一道屏障，本篇结合真实案例及相关资料，汇总整理了前端方面的安全防护措施,请大家一定要重视。如有遇到新的问题，欢迎反馈。</p><p>安全是相对于风险来讲的，风险一直伴随着互联网，攻击者出于不同目的，通过恶意代码、漏洞、网页仿冒等各种手段对WEB进行攻击，防御者不断通过各种修复方法来应对，随着互联网的发展，大家的安全意识也越来越强，比如HTTPS协议的使用就是提升web安全的一项措施，但是安全问题仍遍布互联网的角角落落，需要我们每个人一起努力守护。下面的内容主要收集了WEB前端方面发现的安全问题及修复办法，了解之前，让我们先来看看几条防御原则：</p><ul><li><strong>不要在页面中插入任何不可信数据，除非这些数据已经据根据编码规则进行了编码</strong></li></ul><p>HTML 里有太多地方容易形成XSS漏洞而且形成漏洞的原因又有差别，比如有些漏洞发生在HTML标签里，有些发生在HTML标签的属性里，还有的发生在页面的<code>&lt;script&gt;</code>里，甚至有些还出现在CSS里，再加上不同的浏览器对页面的解析或多或少有些不同，使得有些漏洞只在特定浏览器里才会产生。<br>关于XSS的漏洞，想要了解详细内容可以阅读 <a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet" target="_blank" rel="noopener" title="XSS Filter Evasion Cheat Sheet ；">XSS Filter Evasion Cheat Sheet ；</a>如果英文阅读不便，可以阅读 <a href="https://www.zybuluo.com/laodao/note/9592" target="_blank" rel="noopener" title="XSS防御备忘录中文版">XSS防御备忘录中文版</a></p><ul><li>页面中不要引用外部CDN资源的JavaScript文件、CSS文件</li><li>对用户输入的内容进行安全性验证</li></ul><h2 id="常见的前端安全问题"><a href="#常见的前端安全问题" class="headerlink" title="常见的前端安全问题"></a>常见的前端安全问题</h2><p>前端的安全问题主要集中在跨站脚本攻击(XSS)这一类，产生XSS漏洞的原因各种各样，对于漏洞的利用也是花样百出，我们先来认识下它。<br>跨站脚本攻击（Cross Site Scripting）为不和 CSS混淆，故将跨站脚本攻击缩写为XSS。<br>恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。</p><h3>防范XSS：</h3><ul><li>对输入进行验证</li><li>对输出进行编码</li></ul><p>想详细了解可以参考这两篇文章 《<a href="https://www.owasp.org/index.php/Cross-site_Scripting_(XSS" target="_blank" rel="noopener">Cross-site Scripting (XSS)</a>》 和 《<a href="https://www.owasp.org/index.php/DOM_Based_XSS" target="_blank" rel="noopener" title="DOM Based XSS">DOM Based XSS</a>》</p><h2 id="URL跳转漏洞"><a href="#URL跳转漏洞" class="headerlink" title="URL跳转漏洞"></a>URL跳转漏洞</h2><p>借助未验证的URL跳转，将应用程序引导到不安全的第三方区域，从而导致的安全问题。<br>由于是从可信的站点跳转出去的，用户会比较信任，所以跳转漏洞一般用于钓鱼攻击，通过转到恶意网站欺骗用户输入用户名和密码盗取用户信息，或欺骗用户进行金钱交易；<br>也可能引发的XSS漏洞（主要是跳转常常使用302跳转，即设置HTTP响应头，Locatioin: url，如果url包含了CRLF，则可能隔断了http响应头，使得后面部分落到了http body，从而导致xss漏洞）。</p><h3>修复方法</h3><ul><li>在控制页面转向的地方校验传入的 URL 是否为可信域名。</li><li>接入防御JS代码</li></ul><h3>漏洞检测</h3><p>修改参数中的合法URL为非法URL，然后查看是否能正常跳转或者响应包是否包含了任意的构造URL</p><h2 id="target-”-blank”-存在跳转风险"><a href="#target-”-blank”-存在跳转风险" class="headerlink" title="target=”_blank” 存在跳转风险"></a>target=”_blank” 存在跳转风险</h2><p>带有 target=”_blank” 跳转的网页拥有了浏览器 window.opener 对象赋予的对原网页的跳转权限，这可能会被恶意网站利用，例如一个恶意网站在某 UGC 网站 Po 了其恶意网址，该 UGC 网站用户在新窗口打开页面时，恶意网站利用该漏洞将原 UGC 网站跳转到伪造的钓鱼页面，用户返回到原窗口时可能会忽视浏览器 URL 已发生了变化，伪造页面即可进一步进行钓鱼或其他恶意行为…</p><p><strong>修复方法：</strong> 为 target=”_blank” 加上 rel=”noopener noreferrer” 属性。</p><h2 id="JQUERY的下列方法存在XSS的风险，在使用前应该对输入的内容进行编码或检查"><a href="#JQUERY的下列方法存在XSS的风险，在使用前应该对输入的内容进行编码或检查" class="headerlink" title="JQUERY的下列方法存在XSS的风险，在使用前应该对输入的内容进行编码或检查"></a>JQUERY的下列方法存在XSS的风险，在使用前应该对输入的内容进行编码或检查</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.html(val) | $(<span class="string">"#MyH"</span>).html(<span class="string">"as&gt;/"</span> &lt;img src=abc.jpg onerror=<span class="string">'alert(0);'</span>&gt;alert(<span class="string">'s'</span>);<span class="string">");</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">.append(val)|$("#MyH").append("&lt;strong&gt;Hello&lt;/strong&gt;&lt;script&gt;alert(3);");</span><br><span class="line"></span><br><span class="line">.prepend(val)|$(<span class="string">"#MyH"</span>).prepend(<span class="string">"&lt;strong&gt;Hello&lt;/strong&gt;&lt;script&gt;alert(3);"</span>);</span><br><span class="line"></span><br><span class="line">.before(val)|$(<span class="string">"#MyH"</span>).before(<span class="string">"&lt;strong&gt;Hello&lt;/strong&gt;&lt;script&gt;alert(3);"</span>);</span><br><span class="line"></span><br><span class="line">.replaceWith(val)|$(<span class="string">"#MyH"</span>).replaceWith(<span class="string">"&lt;strong&gt;Hello&lt;/strong&gt;&lt;script&gt;alert(3);"</span>);</span><br><span class="line"></span><br><span class="line">.after(val)|$(<span class="string">"#MyH"</span>).after(<span class="string">"&lt;strong&gt;Hello&lt;/strong&gt;&lt;script&gt;alert(3);"</span>);</span><br></pre></td></tr></table></figure><p><strong>修复方法：</strong></p><ul><li>在使用前应该对输入的内容进行编码或检查</li><li>使用.text()方法替换.html()方法操作元素内容</li></ul><h2 id="防御-修复方法"><a href="#防御-修复方法" class="headerlink" title="防御/修复方法"></a>防御/修复方法</h2><ul><li>接入防御JS代码</li><li>使用https协议，页面中的资源的引用目前使用自适应的写法</li></ul><h2 id="检测工具"><a href="#检测工具" class="headerlink" title="检测工具"></a>检测工具</h2><ol><li>代理类检测 Webscarab，OWASP-开放Web应用程序安全项目</li><li>综合扫描类工具 skipfish，谷歌开源的</li><li>Web安全测试平台 <a href="https://www.oschina.net/p/vega" target="_blank" rel="noopener" title="Vega Platform">Vega Platform</a></li><li>抓包工具 - HttpWatch</li><li>AppScan</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Arena Of Valor（王者荣耀）战绩板网页挂件</title>
    <url>/passages/12/</url>
    <content><![CDATA[<!-- build time:Sat Apr 04 2020 13:08:48 GMT+0800 (GMT+08:00) --><p>折腾完技术，该开始折腾游戏了。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天闲来无事，网上冲浪。看到一篇CS-GO玩家博主的博文<a href="https://www.webaun.cn/passages/12/#附言" title="「1」">「1」</a>，通过调用CS-GO的api查询自己的战绩并生成一个战绩表挂在自己的博客上。效果如下：</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Aunger-ops/myblog@latest/images/2020/12/1.png" alt="  王者荣耀战绩板 " title=" 王者荣耀战绩板"></p><p>觉得相当帅。我平时大部分时间都花在折腾技术上，唯一喜爱打的游戏就只有王者了。于是花了1个小时自制出王者的战绩板挂件。</p><h2 id="寻找API"><a href="#寻找API" class="headerlink" title="寻找API"></a>寻找API</h2><p>既然要查询战绩信息，那也得有个查询的接口（API）啊。折腾半个多小时，在王者的玩家主页上找到了GetHeroSkin的地址：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;mapps.game.qq.com&#x2F;yxzj&#x2F;web201605&#x2F;GetHeroSkin.php?appid&#x3D;wx95a3a4d7c627e07d&amp;area&#x3D;X&amp;partition&#x3D;XXXX&amp;roleid&#x3D;XXXX&amp;r&#x3D;XXXX</span><br></pre></td></tr></table></figure><p>相关GET参数：</p><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>appid</td><td>微信或QQ的appid</td></tr><tr><td>area</td><td>地区id（应该是区别微信和手Q的id）</td></tr><tr><td>partition</td><td>分区id</td></tr><tr><td>roleid</td><td>玩家角色id</td></tr><tr><td>r</td><td><code>Math.rondom()</code> 0-1的随机数</td></tr></tbody></table><p>这些参数都可以通过Console控制台获取。<br>Cookie的获取方法可参考👉：<a href="https://www.webaun.cn/passages/11/" title="https://www.webaun.cn/passages/11/">https://www.webaun.cn/passages/11/</a></p><h2 id="返回示例"><a href="#返回示例" class="headerlink" title="返回示例"></a>返回示例</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"iRet"</span>: <span class="number">0</span>,</span><br><span class="line">	<span class="attr">"sMsg"</span>: <span class="string">"succ"</span>,</span><br><span class="line">	<span class="attr">"data"</span>: &#123;</span><br><span class="line">		<span class="attr">"idip_info"</span>: &#123;</span><br><span class="line">			<span class="attr">"charac_name"</span>: <span class="string">"%E5%8F%AB%E6%88%91%E4%BA%8E%E6%99%8F%E5%90"</span>,</span><br><span class="line">			<span class="attr">"pvplevel"</span>: <span class="string">"30"</span>,</span><br><span class="line">			<span class="attr">"grade_level"</span>: <span class="string">"14"</span>,</span><br><span class="line">			<span class="attr">"head_url"</span>: <span class="string">"http%3A%2F%2Fwx%2Eqlogo%2Ecn%2Fmmhead%2FQ3auHgzwzM4EFibC9YyeOTJvOTq2aG7q28VjB3fzg"</span>,</span><br><span class="line">			<span class="attr">"uid"</span>: <span class="string">"1231565"</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">"history"</span>: &#123;</span><br><span class="line">			<span class="attr">"one_vs_one_lose_num"</span>: <span class="string">"1"</span>,</span><br><span class="line">			<span class="attr">"one_vs_one_win_num"</span>: <span class="string">"2"</span>,</span><br><span class="line">			<span class="attr">"three_vs_three_lose_num"</span>: <span class="string">"3"</span>,</span><br><span class="line">			<span class="attr">"three_vs_three_win_num"</span>: <span class="string">"3"</span>,</span><br><span class="line">			<span class="attr">"five_vs_five_lose_num"</span>: <span class="string">"104"</span>,</span><br><span class="line">			<span class="attr">"five_vs_five_win_num"</span>: <span class="string">"129"</span>,</span><br><span class="line">			<span class="attr">"ladder_win_num"</span>: <span class="string">"201"</span>,</span><br><span class="line">			<span class="attr">"ladder_lose_num"</span>: <span class="string">"191"</span>,</span><br><span class="line">			<span class="attr">"total_lose_num"</span>: <span class="string">"314"</span>,</span><br><span class="line">			<span class="attr">"total_win_num"</span>: <span class="string">"350"</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="attr">"hero_skin_list"</span>: &#123;</span><br><span class="line">			<span class="attr">"HeroListStr"</span>: [</span><br><span class="line">				<span class="string">"166"</span>,</span><br><span class="line">				<span class="string">"109"</span>,</span><br><span class="line">				<span class="string">"112"</span>,</span><br><span class="line">				<span class="string">"142"</span></span><br><span class="line">			],</span><br><span class="line">			<span class="attr">"HeroListCount"</span>: <span class="number">100</span>,</span><br><span class="line">			<span class="attr">"HeroSkinStr"</span>: &#123;</span><br><span class="line">				<span class="attr">"106"</span>: <span class="string">"1"</span>,</span><br><span class="line">				<span class="attr">"109"</span>: <span class="string">"10101"</span>,</span><br><span class="line">				<span class="attr">"111"</span>: <span class="string">"1"</span>,</span><br><span class="line">				<span class="attr">"112"</span>: <span class="string">"1"</span>,</span><br><span class="line">				<span class="attr">"114"</span>: <span class="string">"1"</span>,</span><br><span class="line">				<span class="attr">"115"</span>: <span class="string">"1"</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">"HeroSkinCount"</span>: <span class="number">100</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取数据，生成战绩板"><a href="#获取数据，生成战绩板" class="headerlink" title="获取数据，生成战绩板"></a>获取数据，生成战绩板</h2><p>万事具备，着手开始战绩板的设计和开发。<br>代码可到我的Github仓库获取👉:<a href="https://github.com/Aunger-ops/Arena-Of-Valor-Battleboard" target="_blank" rel="noopener" title="王者荣耀战绩板 网页挂件">王者荣耀战绩板 网页挂件</a></p><p>在您所需要的导出战绩板的地方加入以下js代码即可完成战绩板的生成。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span> </span><br><span class="line"><span class="css"><span class="selector-class">.king-box</span>&#123; </span></span><br><span class="line"><span class="css">    <span class="selector-tag">display</span><span class="selector-pseudo">:block</span>; </span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:500px</span>; </span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:220px</span>; </span></span><br><span class="line"><span class="css">    <span class="selector-tag">border-radius</span><span class="selector-pseudo">:4px</span>; </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">class</span>=<span class="string">"king-box"</span> <span class="attr">src</span>=<span class="string">"你的程序地址"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p>（是的我准备出来丢脸了😂）</p><p>宽度自适应，特殊宽度有特殊处理</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Aunger-ops/myblog@latest/images/2020/12/2.png" alt="  王者荣耀战绩板 " title=" 王者荣耀战绩板"></p><p>（是的UI界面是抄袭的，因为我想不出比这更好的UI界面了😐)</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol><li>本挂件只用于学习交流，休闲娱乐用途。一切解释权在作者手中。任何用在非法用途的使用者一切后果自负。</li><li>若此程序危害了您的利益，请联系笔者删除。Email : anjiejo「AT」qq.com</li><li>若您有很好的建设性意见，欢迎在留言处提出。</li></ol><h2 id="更新动向"><a href="#更新动向" class="headerlink" title="更新动向"></a>更新动向</h2><ul><li><strong>2020-03-25</strong> 将数据保存至本地的方法解决cookie时限短暂问题(如有更好解决方法，欢迎反馈😄)</li></ul><h2 id="附言"><a href="#附言" class="headerlink" title="附言"></a>附言</h2><p><a href="http://mouto.org/note/170" target="_blank" rel="noopener" title="「1」 CS-GO战绩板网页挂件 ： http://mouto.org/note/170">「1」 CS-GO战绩板网页挂件 ： http://mouto.org/note/170</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JS</category>
        <category>前端</category>
        <category>UI设计</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端</tag>
        <tag>王者荣耀</tag>
        <tag>API</tag>
        <tag>PHP</tag>
        <tag>UI设计</tag>
      </tags>
  </entry>
  <entry>
    <title>简单导出网站的cookie</title>
    <url>/passages/11/</url>
    <content><![CDATA[<!-- build time:Sat Apr 04 2020 13:08:48 GMT+0800 (GMT+08:00) --><p>网上的导出特定网站的cookie方法多种多样，大多操作复杂，这是我总结得出的简单一步导出相应网站cookie。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>网上的导出特定网站的cookie方法多种多样，但大多操作复杂，有：</p><ul><li>直接访问IE浏览器“文件”导出的： <a href="https://jingyan.baidu.com/article/6fb756ec733a30241958fb66.html" target="_blank" rel="noopener" title="IE文件导出Cookie">IE文件导出Cookie</a></li><li>访问Network查看cookie的： <a href="https://blog.csdn.net/qq_39708579/article/details/79351460" target="_blank" rel="noopener" title="访问Network查看cookie">访问Network查看cookie</a></li></ul><p>但操作复杂，这里给出一个操作简单，一步到位的cookie导出方法。</p><h2 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h2><p>F12打开开发者工具，找到console页面，输入</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie</span><br></pre></td></tr></table></figure><p>既可以查看。复制出来即可。</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Aunger-ops/myblog@latest/images/2020/11/1.png" alt=" 简单操作导出cookie " title=" 简单操作导出cookie"></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端</tag>
        <tag>Console</tag>
      </tags>
  </entry>
  <entry>
    <title>设备智能化「在家」状态的一些思考</title>
    <url>/passages/9/</url>
    <content><![CDATA[<!-- build time:Sat Apr 04 2020 13:08:48 GMT+0800 (GMT+08:00) --><p>HomeAssistant的Devicetracker是个非常有用的组件，通过设备追踪可以判断设备的在线情况从而执行不同的自动化操作。可是iPhone的睡眠策略（长时间睡眠后断开WiFI）会导致设备追踪误以为设备已经离开从而执行「不在家」的自动化…..</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HomeAssistant的Devicetracker是个非常有用的组件，通过设备追踪可以判断设备的在线情况从而执行不同的自动化操作。</p><p>可是iPhone的睡眠策略（长时间睡眠后断开WiFI）会导致设备追踪误以为设备已经离开从而执行「不在家」的自动化。</p><p>就像这样：</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Aunger-ops/myblog@latest/images/2020/09/1.jpg" alt=" 设备智能化「在家」状态的一些思考" title=" 设备智能化「在家」状态的一些思考"></p><p>大家的解决方案也是很多：</p><ul><li>追踪WIFI和蓝牙两者都断开则为「离开」</li><li>通过家门口的人体传感器联动判断是否是「回家」</li><li>通过人脸识别检测是否是「回家」</li></ul><p>但是当「出去扔个垃圾再回家」后却仍然执行了「回家」自动化。有天看到Phil论坛有个网友提出了是否在家的5种状态，完美的解决了这个问题。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>这个组件采用了一个input_select来存储设备是否在家的 5 种状态：</p><table><thead><tr><th>状态</th><th>描述</th></tr></thead><tbody><tr><td>JUST ARRIVED</td><td>刚刚到家</td></tr><tr><td>HOME</td><td>在家</td></tr><tr><td>JUST LEFT</td><td>刚刚离开</td></tr><tr><td>AWAY</td><td>离开</td></tr><tr><td>EXTENDED AWAY</td><td>长时间离开</td></tr></tbody></table><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">input_select:</span></span><br><span class="line">  <span class="attr">hades_status_dropdown:</span></span><br><span class="line">    <span class="attr">options:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Home</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Just</span> <span class="string">Arrived</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Just</span> <span class="string">Left</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Away</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">Extended</span> <span class="string">Away</span></span><br><span class="line">    <span class="attr">initial:</span> <span class="string">Home</span></span><br></pre></td></tr></table></figure><p>然后通过一个Sensor组件来显示这个设备的状态：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sensor:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">platform:</span> <span class="string">template</span></span><br><span class="line">    <span class="attr">sensors:</span></span><br><span class="line">      <span class="attr">hades_status:</span></span><br><span class="line">        <span class="attr">value_template:</span> <span class="string">"<span class="template-variable">&#123;&#123; states.input_select.hades_status_dropdown.state &#125;&#125;</span>"</span></span><br><span class="line">        <span class="attr">friendly_name:</span> <span class="string">'hades status'</span></span><br></pre></td></tr></table></figure><h2 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h2><p>因为原来的设备只有两种状态，而新的组件通过「刚刚到家」、「刚刚离开」这两种「过渡态」让系统可以判断出是否是临时断线或者是是否是第一次回家。</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Aunger-ops/myblog@latest/images/2020/09/2.jpg" alt=" 设备智能化「在家」状态的一些思考" title=" 设备智能化「在家」状态的一些思考"></p><p>当回家时，状态过渡为「Just Arrived」，「Just Arrived」持续 10 秒钟后可以认为已经到家了，状态改为「Home」，可以执行「回家」自动化。</p><p>当手机睡眠断线或者出去拿外卖、扔垃圾时，状态过渡为「Just Away」，在一个时间之后（比如 10 分钟）仍然无法追踪到设备，此时系统可以理解设备是真的离开家了，所以状态过渡为「Away」，执行「离家」自动化。</p><p>当长时间（24 小时）设备仍然离线，那我应该是去旅游去了哈哈哈哈，此时状态改为「Extended Away」。</p><h2 id="自动化"><a href="#自动化" class="headerlink" title="自动化"></a>自动化</h2><p>但是这样有个缺点，需要执行 5 个自动化来判断所有的状态。</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">automation:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">'156766432451'</span></span><br><span class="line">  <span class="attr">alias:</span> <span class="string">标记为刚刚到家(Just</span> <span class="string">Arrived)</span></span><br><span class="line">  <span class="attr">trigger:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">entity_id:</span> <span class="string">device_tracker.e4_9a_dc_bf_9a_de</span></span><br><span class="line">    <span class="attr">from:</span> <span class="string">not_home</span></span><br><span class="line">    <span class="attr">platform:</span> <span class="string">state</span></span><br><span class="line">    <span class="attr">to:</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">condition:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">condition:</span> <span class="string">state</span></span><br><span class="line">    <span class="attr">entity_id:</span> <span class="string">sensor.hades_status</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">Away</span></span><br><span class="line">  <span class="attr">action:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">data:</span></span><br><span class="line">      <span class="attr">entity_id:</span> <span class="string">input_select.hades_status_dropdown</span></span><br><span class="line">      <span class="attr">option:</span> <span class="string">Just</span> <span class="string">Arrived</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">input_select.select_option</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">'156764685703'</span></span><br><span class="line">  <span class="attr">alias:</span> <span class="string">标记为真正到家(Home)</span></span><br><span class="line">  <span class="attr">trigger:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">entity_id:</span> <span class="string">input_select.hades_status_dropdown</span></span><br><span class="line">    <span class="attr">for:</span> <span class="number">00</span><span class="string">:00:10</span></span><br><span class="line">    <span class="attr">platform:</span> <span class="string">state</span></span><br><span class="line">    <span class="attr">to:</span> <span class="string">Just</span> <span class="string">Arrived</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">entity_id:</span> <span class="string">input_select.hades_status_dropdown</span></span><br><span class="line">    <span class="attr">from:</span> <span class="string">Just</span> <span class="string">Left</span></span><br><span class="line">    <span class="attr">platform:</span> <span class="string">state</span></span><br><span class="line">    <span class="attr">to:</span> <span class="string">Just</span> <span class="string">Arrived</span></span><br><span class="line">  <span class="attr">condition:</span> <span class="string">[]</span></span><br><span class="line">  <span class="attr">action:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">data:</span></span><br><span class="line">      <span class="attr">entity_id:</span> <span class="string">input_select.hades_status_dropdown</span></span><br><span class="line">      <span class="attr">option:</span> <span class="string">Home</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">input_select.select_option</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">'156766457492'</span></span><br><span class="line">  <span class="attr">alias:</span> <span class="string">标记为刚刚离开(Just</span> <span class="string">Left)</span></span><br><span class="line">  <span class="attr">trigger:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">entity_id:</span> <span class="string">device_tracker.e4_9a_dc_bf_9a_de</span></span><br><span class="line">    <span class="attr">from:</span> <span class="string">home</span></span><br><span class="line">    <span class="attr">platform:</span> <span class="string">state</span></span><br><span class="line">    <span class="attr">to:</span> <span class="string">not_home</span></span><br><span class="line">  <span class="attr">condition:</span> <span class="string">[]</span></span><br><span class="line">  <span class="attr">action:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">data:</span></span><br><span class="line">      <span class="attr">entity_id:</span> <span class="string">input_select.hades_status_dropdown</span></span><br><span class="line">      <span class="attr">option:</span> <span class="string">Just</span> <span class="string">Left</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">input_select.select_option</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">'156766995990'</span></span><br><span class="line">  <span class="attr">alias:</span> <span class="string">标记为真正离开(Away)</span></span><br><span class="line">  <span class="attr">trigger:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">entity_id:</span> <span class="string">input_select.hades_status_dropdown</span></span><br><span class="line">    <span class="attr">for:</span> <span class="number">00</span><span class="string">:10:00</span></span><br><span class="line">    <span class="attr">platform:</span> <span class="string">state</span></span><br><span class="line">    <span class="attr">to:</span> <span class="string">Just</span> <span class="string">Left</span></span><br><span class="line">  <span class="attr">condition:</span> <span class="string">[]</span></span><br><span class="line">  <span class="attr">action:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">data:</span></span><br><span class="line">      <span class="attr">entity_id:</span> <span class="string">input_select.hades_status_dropdown</span></span><br><span class="line">      <span class="attr">option:</span> <span class="string">Away</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">input_select.select_option</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">id:</span> <span class="string">'156766190138'</span></span><br><span class="line">  <span class="attr">alias:</span> <span class="string">标记为真正离开(Home</span> <span class="string">ahadesistant</span> <span class="string">Start)</span></span><br><span class="line">  <span class="attr">trigger:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">event:</span> <span class="string">start</span></span><br><span class="line">    <span class="attr">platform:</span> <span class="string">homeahadesistant</span></span><br><span class="line">  <span class="attr">condition:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">condition:</span> <span class="string">state</span></span><br><span class="line">    <span class="attr">entity_id:</span> <span class="string">device_tracker.e4_9a_dc_bf_9a_de</span></span><br><span class="line">    <span class="attr">state:</span> <span class="string">not_home</span></span><br><span class="line">  <span class="attr">action:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">data:</span></span><br><span class="line">      <span class="attr">entity_id:</span> <span class="string">input_select.hades_status_dropdown</span></span><br><span class="line">      <span class="attr">option:</span> <span class="string">Away</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">input_select.select_option</span></span><br></pre></td></tr></table></figure><p>其中，For为持续的时间，可以根据实际情况修改需要的时间。目前只能追踪单个设备，而更多的设备可以使用作者的模板，添加不同的设备来追踪。</p><p>这样子，只需要根据 Sensor 这个组件的状态是不是从「Just Arrived」到「Home」就能判断出是不是回家了。</p><h2 id="Hub-Center"><a href="#Hub-Center" class="headerlink" title="Hub Center"></a>Hub Center</h2><p>Home Assistant 提供了一套 <a href="https://www.home-assistant.io/docs/ecosystem/hadashboard/" target="_blank" rel="noopener" title="HADashboard">HADashboard</a>，可以通过简洁的面板显示所有设备的状态：</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Aunger-ops/myblog@latest/images/2020/09/3.png" alt=" 设备智能化「在家」状态的一些思考" title=" 设备智能化「在家」状态的一些思考"></p><p>有时候通过 HomePod 传达指令后就忘记了设备是否打开，所以一直想使用一块屏幕来显示家里的设备信息。但是需要当我「离开」的时候自动关闭屏幕。「在家」状态搞定后，可以更好的控制 Hub Center 了。</p><p>Hub Center 的自动化应该这样设置：</p><ul><li>当我到家后，开启 Hub Center</li><li>当我离开后，关闭 Hub Center</li><li>当我睡觉时，执行场景关闭 Hub Center</li></ul><p>有了自动化，就应该考虑到使用什么来显示 Hub Center 了。</p><h2 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h2><p>iPad 似乎是个不错的选择，但是不能远程 / 局域网内控制屏幕的开启与关闭，正好前几天拆解了一台笔记本，剩下了一个屏幕，接入一个驱动版就可以显示了。</p><p>但是某宝看了一圈，外漏驱动版似乎不太安全，定制外壳又很贵，最重要的是树莓派在房间的一个角落，如果连接树莓派的话需要 8 米的 HDMI 线，外壳 + HDMI 线成本就上去了。于是想到了被遗弃的安卓机，已经 Root，通过 ADB 来控制屏幕的开启与关闭，简直完美。</p><h2 id="ADB-远程调试"><a href="#ADB-远程调试" class="headerlink" title="ADB 远程调试"></a>ADB 远程调试</h2><p>通过 USB 连接电脑，adb devices查看设备，这种方法需要 root 权限：</p><p>将/system/build.prop文件从手机pull出来：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell pull &#x2F;system&#x2F;build.prop</span><br></pre></td></tr></table></figure><p>添加配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;system&#x2F;build.prop </span><br><span class="line">+ service.adb.tcp.port&#x3D;5555</span><br></pre></td></tr></table></figure><p>最后在push到设备中：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb push build.prop &#x2F;system&#x2F;</span><br></pre></td></tr></table></figure><p>这样就可以通过远程连接到设备了。</p><h2 id="模拟电源键"><a href="#模拟电源键" class="headerlink" title="模拟电源键"></a>模拟电源键</h2><p>通过模拟电源按键来实现屏幕的开启与关闭：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb connect 192.168.1.127:5555</span><br><span class="line">adb shell input keyevent 26</span><br><span class="line">adb disconnect</span><br></pre></td></tr></table></figure><h2 id="Hub-Center-状态"><a href="#Hub-Center-状态" class="headerlink" title="Hub Center 状态"></a>Hub Center 状态</h2><p>手机一直连接充电器是非常危险的，需要知道手机的剩余电量，在电量低的时候自动充电。所以需要一个组件来保存设备的状态信息，在 Home Assistant 里添加template的sensor：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sensor:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">platform:</span> <span class="string">template</span></span><br><span class="line">    <span class="attr">sensors:</span></span><br><span class="line">      <span class="attr">hub_level:</span></span><br><span class="line">        <span class="attr">value_template:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">unit_of_measurement:</span> <span class="string">'%'</span></span><br><span class="line">        <span class="attr">friendly_name:</span> <span class="string">'Hub Level'</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">platform:</span> <span class="string">template</span></span><br><span class="line">    <span class="attr">sensors:</span></span><br><span class="line">      <span class="attr">hub_temperature:</span></span><br><span class="line">        <span class="attr">value_template:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">unit_of_measurement:</span> <span class="string">'°C'</span></span><br><span class="line">        <span class="attr">friendly_name:</span> <span class="string">'Hub Temperature'</span></span><br></pre></td></tr></table></figure><p>使用 Python 来推送设备的信息至 Home Assistant：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">os.popen(<span class="string">'adb connect 192.168.1.127:5555'</span>)</span><br><span class="line">tmp = os.popen(<span class="string">'adb shell dumpsys battery'</span>).readlines()</span><br><span class="line">os.popen(<span class="string">'adb disconnect'</span>)</span><br><span class="line"></span><br><span class="line">level = re.findall(<span class="string">'\d+'</span>,tmp[<span class="number">9</span>])[<span class="number">0</span>]</span><br><span class="line">temperature = re.findall(<span class="string">'\d+'</span>,tmp[<span class="number">13</span>])[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">"Content-Type"</span>: <span class="string">"application/json"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_state</span><span class="params">(id, state)</span>:</span></span><br><span class="line">    requests.post(<span class="string">'http://localhost/api/states/'</span> + id, headers = headers, data = json.dumps(&#123;</span><br><span class="line">        <span class="string">"state"</span>: state</span><br><span class="line">    &#125;), stream=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">set_state(<span class="string">'sensor.hub_level'</span>, level)</span><br><span class="line">set_state(<span class="string">'sensor.hub_temperature'</span>, int(temperature) / <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>最后使用crontab任务定时更新这个组件的状态，每 10 分钟更新一下数据。这样，Home Assistant 里就可以得到设备的电量和温度信息，在电量低于 15% 的时候打开插座就可以给手机充电了。</p><p>😺 温度的作用是来监控设备的充电状态，当充电时设备温度高时自动切断充电电源：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="attr">alias:</span> <span class="string">温度异常</span></span><br><span class="line">  <span class="attr">sequence:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">data:</span></span><br><span class="line">      <span class="attr">message:</span> <span class="string">已关闭Hub充电插座电源</span></span><br><span class="line">      <span class="attr">title:</span> <span class="string">Hub设备温度超过50℃</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">notify.me</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">data:</span></span><br><span class="line">      <span class="attr">entity_id:</span> <span class="string">switch.plug_hub</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">switch.turn_off</span></span><br></pre></td></tr></table></figure><h2 id="控制屏幕"><a href="#控制屏幕" class="headerlink" title="控制屏幕"></a>控制屏幕</h2><p>有了 ADB 工具就可以做许多事情了，使用 Home Assistant 的shell_command组件就可以控制设备屏幕的开启与关闭：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">shell_command:</span></span><br><span class="line"> <span class="attr">hub_power:</span> <span class="string">adb</span> <span class="string">shell</span> <span class="string">input</span> <span class="string">keyevent</span> <span class="number">26</span></span><br></pre></td></tr></table></figure><blockquote><p>This integration can expose regular shell commands as services. Services can be called from a <a href="https://www.home-assistant.io/components/script/" target="_blank" rel="noopener" title="script">script</a> or in <a href="https://www.home-assistant.io/getting-started/automation/" target="_blank" rel="noopener" title="automation">automation</a>. Shell commands aren’t allowed for a camel-case naming, please use lowercase naming only and separate the names with underscores.</p></blockquote><p>通过这个组件所有的命令就可以接入到自动化中。</p><h2 id="充电关闭屏幕"><a href="#充电关闭屏幕" class="headerlink" title="充电关闭屏幕"></a>充电关闭屏幕</h2><p>还有一个比较麻烦的事情就是，当我不在家时进行充电会激活屏幕显示，而 Hub 设置了永不锁屏，所以需要判断我是否在家从而关闭屏幕。</p><p>执行充电操作后，如果我不在家，通过<code>adb shell dumpsys power</code>来检测设备是否休眠，若不在休眠中（亮屏）则关闭屏幕：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="string">STATUS=$(adb</span> <span class="string">shell</span> <span class="string">dumpsys</span> <span class="string">power</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">-i</span> <span class="string">"Display Power"</span><span class="string">)</span></span><br><span class="line"><span class="string">if</span> <span class="string">[[</span> <span class="string">"$STATUS"</span> <span class="string">=~</span> <span class="string">"Display Power: state=ON"</span> <span class="string">]]</span></span><br><span class="line"><span class="string">then</span></span><br><span class="line">    <span class="string">adb</span> <span class="string">shell</span> <span class="string">input</span> <span class="string">keyevent</span> <span class="number">26</span></span><br><span class="line"><span class="string">fi</span></span><br></pre></td></tr></table></figure><p>现在所有的设备已经全部接入到了 Home Assistant 了，通过构建不同的自动化操作就可以做到「回家开启 Hub Center」、「出门关闭 Hub Center」、「低电量自动充电」、「充电完成关闭插座」等自动化了。</p><p>转载自：<a href="https://blog.mayuko.cn/code/more-well-home-status/" target="_blank" rel="noopener" title="Hades">Hades</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>嵌入式</category>
        <category>智能家居</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>物联网</tag>
        <tag>智能设备</tag>
        <tag>智能家居</tag>
        <tag>HomeAssistant</tag>
      </tags>
  </entry>
  <entry>
    <title>用JS写前端可预测的随机</title>
    <url>/passages/8/</url>
    <content><![CDATA[<!-- build time:Sat Apr 04 2020 13:08:48 GMT+0800 (GMT+08:00) --><p>从一次游戏活动页面学习到的JS完成前端运行可预测、可控制的随机文字生成。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>“我要实现一个随机效果，把预设的文案打乱排列”</p><p>—— Math.random就能搞定</p><p>“需要做到每次进来，看到的结果和上次一样。”</p><p>—— 那我用localstorage存起来吧</p><p>“要是我换了手机、换了浏览器，也要看到一致的结果。”</p><p>—— 额，好像需要后台记录了。</p><p>“后台说为每个用户记录所有的文案压力可能会比较大”</p><p>我们把问题转化一下，变成“如何在前端写可控的随机，每次都能得到确定的结果。</p><p>以上就是刺激战场世界杯期间的一个活动需求。前端根据比分和用户id，生成的一场模拟的文字直播，效果如下。</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Aunger-ops/myblog@latest/images/2020/08/1.gif" alt="一场在前端生成的文字直播" title="一场在前端生成的文字直播"></p><h2 id="逻辑整理"><a href="#逻辑整理" class="headerlink" title="逻辑整理"></a>逻辑整理</h2><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Aunger-ops/myblog@latest/images/2020/08/2.jpg" alt="一场在前端生成的文字直播" title="一场在前端生成的文字直播"></p><p>流程中循环的那部分，算作一个回合。每个回合，不管是进攻成功还是失败，都是以“进攻中”开始，以“交换球权”作为结束；成功失败只影响是否积分。</p><h2 id="文案分类"><a href="#文案分类" class="headerlink" title="文案分类"></a>文案分类</h2><p>文案是按照进攻中、进攻成功、进攻失败、氛围类来分类的。</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Aunger-ops/myblog@latest/images/2020/08/3.png" alt="一场在前端生成的文字直播" title="一场在前端生成的文字直播"></p><h2 id="比赛格局生成"><a href="#比赛格局生成" class="headerlink" title="比赛格局生成"></a>比赛格局生成</h2><p>规则定了，先生成比赛格局，比如先谁谁谁发起进攻了，谁谁谁进球了，但具体里面的文案后面再填充。</p><p>这里以双方最终比分2：3的情况来举例。</p><p>第一步，将甲乙两方分数（进球的块）随机 汇合成一个数组</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Aunger-ops/myblog@latest/images/2020/08/4.png" alt="一场在前端生成的文字直播" title="一场在前端生成的文字直播"></p><p>第二步，每个进球前加上一个“进攻中”</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Aunger-ops/myblog@latest/images/2020/08/5.png" alt="一场在前端生成的文字直播" title="一场在前端生成的文字直播"></p><p>第三步，如果两次得分是同一方，之间加入对方“进攻中”+“进攻失败”的块（交换球权）</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Aunger-ops/myblog@latest/images/2020/08/6.png" alt="一场在前端生成的文字直播" title="一场在前端生成的文字直播"></p><h2 id="填充内容"><a href="#填充内容" class="headerlink" title="填充内容"></a>填充内容</h2><p>比赛的格局已经定型，把对应的文字 随机 挑选填充进去</p><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Aunger-ops/myblog@latest/images/2020/08/7.png" alt="一场在前端生成的文字直播" title="一场在前端生成的文字直播"></p><p>有时总比分和太小，比如1:1甚至1:0的情况，会造成回合太少很快结束。</p><p>可在数组中增加一些“进攻中”+“进攻失败”的块，不影响比分。增加偶数组，偶数次交换球权，就又回到原来的球权所在方。</p><p>这种增加的组数可根据总分和来决定。比如，在现有的每组间隔中，分别再手动插入（5减去总分和）组。</p><p>此外有一些场面描写、烘托氛围的语句，和比赛分数、进程没有直接关系的，插入的位置可以使用固定，比如在20%、40%、60%、80%的位置固定插入。</p><p>从上面的分析可以看到，难点就在这里的 随机 ，比赛格局的设定、文案数组的打乱，都需要看起来是随机，又要同一场比赛保持可确定性。</p><h2 id="随机的核心代码"><a href="#随机的核心代码" class="headerlink" title="随机的核心代码"></a>随机的核心代码</h2><p>核心代码主要分为3部分：</p><ol><li>获取随机种子</li><li>随机函数</li><li>根据随机函数生成的随机数，打乱数组</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">array, seed</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// seed:string</span></span><br><span class="line">  <span class="keyword">let</span>  currentIndex = array.length, temporaryValue, randomIndex;</span><br><span class="line">  seed = (seed?seed+<span class="string">''</span> : <span class="string">''</span>);</span><br><span class="line">  <span class="keyword">let</span> seedNum=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; seed.length; index++) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = seed[index];</span><br><span class="line">    seedNum+=element.charCodeAt(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Generate a random num using seed</span></span><br><span class="line">  <span class="comment">// theoretical range:[0,1]</span></span><br><span class="line">  <span class="comment">// actual range:(0,1)</span></span><br><span class="line">  <span class="keyword">let</span> random = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">Math</span>.sin(seedNum++) * <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">return</span> x - <span class="built_in">Math</span>.floor(x);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Shuffle array</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">0</span> !== currentIndex) &#123;</span><br><span class="line">    <span class="comment">// Pick a remaining element...</span></span><br><span class="line">    randomIndex = <span class="built_in">Math</span>.floor(random() * currentIndex);</span><br><span class="line">    currentIndex -= <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// And swap it with the current element.</span></span><br><span class="line">    temporaryValue = array[currentIndex];</span><br><span class="line">    array[currentIndex] = array[randomIndex];</span><br><span class="line">    array[randomIndex] = temporaryValue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步的随机种子获取，这次专题的每次比赛都会有一个比赛的加密字符串，刚好可以用来作为seed种子。</p><p>第二步的随机函数其实是根据sine函数，取预设的取样点处的值的小数部分，每调用一次，取样点的位置+1，所以，定义好之后，在随机种子确定的情况下，第n次调用的值是确定的。</p><p>虽然严格来说，这样的方式不是完全平均分布的随机，但已经可以满足<strong>看起来随机</strong>的需求。</p><p>第三部分的数组打乱，方法是从数组最后一项开始，和前面<strong>随机</strong>挑选的一个项交换，然后倒数第二项，然后倒数第三项……直到第一项。</p><h2 id="前端随机的其他应用"><a href="#前端随机的其他应用" class="headerlink" title="前端随机的其他应用"></a>前端随机的其他应用</h2><p>前端随机的方式，还可以在一些抽签类的小程序中应用。我第一次见到是在全军出击签到小程序中看到，可以利用用户的openid来作为种子生成运势的签序列，然后根据日期作为index去取当天的运势。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array#answer-2450976" target="_blank" rel="noopener" title="How to randomize (shuffle) a JavaScript array?">How to randomize (shuffle) a JavaScript array?</a></p><p><a href="https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript#answer-19303725" target="_blank" rel="noopener" title="Seeding the random number generator in Javascript">Seeding the random number generator in Javascript</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>前端</category>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机之开发环境使用VSCode结合SDCC取代Keil</title>
    <url>/passages/7/</url>
    <content><![CDATA[<!-- build time:Sat Apr 04 2020 13:08:48 GMT+0800 (GMT+08:00) --><p>Keil的编程环境落后、伤眼、用起来不舒适？工欲善其事，必先利其器。VSCode + SDCC助你在C51单片机嵌入式开发上游刃有余。</p><a id="more"></a><h2 id="为什么选择SDCC而不是Keil"><a href="#为什么选择SDCC而不是Keil" class="headerlink" title="为什么选择SDCC而不是Keil"></a>为什么选择SDCC而不是Keil</h2><h4 id="Keil缺点："><a href="#Keil缺点：" class="headerlink" title="Keil缺点："></a>Keil缺点：</h4><ol><li>功能较弱，只适合个人和小团队开发，不适合中型、大型开发</li><li>是收费软件，需要付费，大多数人用 Keil C 都是盗版</li><li>Keil内部中文注释是乱码，配套编辑器缩进不方便</li><li>Keil支持较为局限</li></ol><h4 id="SDCC缺点："><a href="#SDCC缺点：" class="headerlink" title="SDCC缺点："></a>SDCC缺点：</h4><ol><li>SDCC不配套的调试器，不能够调试硬件</li></ol><h2 id="下载与配置"><a href="#下载与配置" class="headerlink" title="下载与配置"></a>下载与配置</h2><ol><li>编辑器我们推荐使用VSCode，并针对VSCode配置了一套设置文件（查看 【 其他资料 】中的<code>VSCode的相应设置文件</code>进行下载）</li><li><a href="https://code.visualstudio.com/download" target="_blank" rel="noopener" title="下载VSCode">下载VSCode</a></li><li>然后根据计算机版本完成VSCode的安装</li><li><a href="https://sourceforge.net/projects/sdcc/files/" target="_blank" rel="noopener" title="下载SDCC">下载SDCC</a></li><li>同样根据自己的系统安装对应版本的SDCC，例如我安装的是<a href="https://sourceforge.net/projects/sdcc/files/sdcc-win64/3.8.0/sdcc-3.8.0-x64-setup.exe/download" target="_blank" rel="noopener" title="SDCCWin64">SDCCWin64</a>的V3.8</li><li>安装好SDCC需要配置Path系统变量</li></ol><h2 id="关于本项目的说明"><a href="#关于本项目的说明" class="headerlink" title="关于本项目的说明"></a>关于本项目的说明</h2><ol><li>VSCode的语法错误提示已经被屏蔽，需要的自行删除.vscode的setting（如果删除语法错误屏蔽，正确的书写方法会报一些错误）</li><li>代码文件默认放在usr文件夹中，临时文件放在tmp文件夹中</li><li>目前的Makefile仅支持C51单文件编译</li><li>Publish的批处理文件是用来一键删除所有的临时文件和生成过的hex文件，如果想要删除tmp文件夹下的临时文件和生成过的hex文件，可以运行publish.bat</li><li>使用时，打开VSCode，点击File-Open Folder，然后选择本repo的文件夹，如果你按照默认目录安装sdcc，你打开一个usr文件夹下的C文件，然后点击Terminal-RunBuildTask，即可成功编译并生成可烧录的hex文件。</li></ol><h2 id="SDCC与Keil语法差异"><a href="#SDCC与Keil语法差异" class="headerlink" title="SDCC与Keil语法差异"></a>SDCC与Keil语法差异</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;8052.h&gt;&#x2F;&#x2F;#include&lt;reg52.h&gt;</span><br><span class="line">#define pin P0_0&#x2F;&#x2F;sbit pin&#x3D;P0^0;</span><br><span class="line">&#x2F;&#x2F;在使用中断函数之前要声明</span><br></pre></td></tr></table></figure><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><ul><li><a href="https://gitee.com/haozewu/C51?_from=gitee_search#sdcc%E5%92%8Ckeil%E8%AF%AD%E6%B3%95%E5%B7%AE%E5%BC%82" target="_blank" rel="noopener">VSCode的相应设置文件</a></li><li><a href="https://www.pjrc.com/tech/8051/" target="_blank" rel="noopener" title="8051例程">8051例程</a></li></ul><!-- rebuild by neat -->]]></content>
      <categories>
        <category>嵌入式开发</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title>Android反编译之Smali语法基础</title>
    <url>/passages/6/</url>
    <content><![CDATA[<!-- build time:Sat Apr 04 2020 13:08:48 GMT+0800 (GMT+08:00) --><p>Smali语法适用于Android逆向分析，是学习Android反编译，审查app应用代码漏洞，破解app应用的基础。本文将分为多章内容，简洁明了说明Smali语法命令的各种意义。让读者快速掌握Smali语法，便利于反编译程序员对记忆不清的命令意义进行搜索。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Smali语法适用于Android逆向分析，是学习Android反编译，审查app应用代码漏洞，破解app应用的基础。本文将分为多章内容，简洁明了说明Smali语法命令的各种意义。让读者快速掌握Smali语法，便利于反编译程序员对记忆不清的命令意义进行搜索。</p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><table><thead><tr><th>代码</th><th>描述</th></tr></thead><tbody><tr><td>.field</td><td>定义变量</td></tr><tr><td>.method</td><td>方法</td></tr><tr><td>.parameter</td><td>方法参数</td></tr><tr><td>.prologue</td><td>方法开始</td></tr><tr><td>.line 12</td><td>此方法位于第12行</td></tr><tr><td>invoke-super</td><td>调用父函数</td></tr><tr><td>const/high16 v0, 0x7fo3</td><td>把0x7fo3赋值给v0</td></tr><tr><td>invoke-direct</td><td>调用函数</td></tr><tr><td>return-void</td><td>函数返回void</td></tr><tr><td>.end method</td><td>函数结束</td></tr><tr><td>new-instance</td><td>创建实例</td></tr><tr><td>iput-object</td><td>对象赋值</td></tr><tr><td>iget-object</td><td>调用对象</td></tr><tr><td>invoke-static</td><td>调用静态函数</td></tr></tbody></table><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><table><thead><tr><th>代码</th><th>类型</th></tr></thead><tbody><tr><td>V</td><td>void</td></tr><tr><td>Z</td><td>boolean</td></tr><tr><td>B</td><td>byte</td></tr><tr><td>S</td><td>short</td></tr><tr><td>C</td><td>char</td></tr><tr><td>I</td><td>int</td></tr><tr><td>J</td><td>long（64位）</td></tr><tr><td>F</td><td>float</td></tr><tr><td>D</td><td>double（64位）</td></tr></tbody></table><h2 id="控制条件"><a href="#控制条件" class="headerlink" title="控制条件"></a>控制条件</h2><table><thead><tr><th>代码</th><th>描述</th></tr></thead><tbody><tr><td>if-eq vA, vB, :cond_**</td><td>如果vA <code>等于</code> vB则跳转到:cond_**</td></tr><tr><td>if-ne vA, vB, :cond_**</td><td>如果vA <code>不等于</code> vB则跳转到:cond_**</td></tr><tr><td>if-lt vA, vB, :cond_**</td><td>如果vA <code>小于</code> vB则跳转到:cond_**</td></tr><tr><td>if-ge vA, vB, :cond_**</td><td>如果vA <code>大于等于</code> vB则跳转到:cond_**</td></tr><tr><td>if-gt vA, vB, :cond_**</td><td>如果vA <code>大于</code> vB则跳转到:cond_**</td></tr><tr><td>if-le vA, vB, :cond_**</td><td>如果vA <code>小于等于</code> vB则跳转到:cond_**</td></tr><tr><td>if-eqz vA, :cond_**</td><td>如果vA <code>等于</code> 0则跳转到:cond_**</td></tr><tr><td>if-nez vA, :cond_**</td><td>如果vA <code>不等于</code> 0则跳转到:cond_**</td></tr><tr><td>if-ltz vA, :cond_**</td><td>如果vA <code>小于</code> 0则跳转到:cond_**</td></tr><tr><td>if-gez vA, :cond_**</td><td>如果vA <code>大于等于</code> 0则跳转到:cond_**</td></tr><tr><td>if-gtz vA, :cond_**</td><td>如果vA <code>大于</code> 0则跳转到:cond_**</td></tr><tr><td>if-lez vA, :cond_**</td><td>如果vA <code>小于等于</code> 0则跳转到:cond_**</td></tr></tbody></table><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><table><thead><tr><th>代码</th><th>描述</th></tr></thead><tbody><tr><td># static fields</td><td>定义静态变量的标记</td></tr><tr><td># instance fields</td><td>定义实例变量的标记</td></tr><tr><td># direct methods</td><td>定义静态方法的标记</td></tr><tr><td># virtual methods</td><td>定义非静态方法的标记</td></tr><tr><td>## 移位操作</td><td></td></tr></tbody></table><table><thead><tr><th>代码</th><th>描述</th></tr></thead><tbody><tr><td>move v1,v2</td><td>将v2中的值移入到v1寄存器中（4位，支持int型）</td></tr><tr><td>move/from16 v1,v2</td><td>将16位的v2寄存器中的值移入到8位的v1寄存器中</td></tr><tr><td>move/16 v1,v2</td><td>将16位的v2寄存器中的值移入到16位的v1寄存器中</td></tr><tr><td>move-wide v1,v2</td><td>将寄存器对（一组，用于支持双字型）v2中的值移入到v1寄存器对中（4位，猜测支持float、double型）</td></tr><tr><td>move-wide/from16 v1,v2</td><td>将16位的v2寄存器对（一组）中的值移入到8位的v1寄存器中</td></tr><tr><td>move-wide/16 v1,v2</td><td>将16位的v2寄存器对（一组）中的值移入到16位的v1寄存器中</td></tr><tr><td>move-object v1,v2</td><td>将v2中的对象指针移入到v1寄存器中</td></tr><tr><td>move-object/from16 v1,v2</td><td>将16位的v2寄存器中的对象指针移入到v1（8位）寄存器中</td></tr><tr><td>move-object/16 v1,v2</td><td>将16位的v2寄存器中的对象指针移入到v1（16位）寄存器中</td></tr><tr><td>move-result v1</td><td>将这个指令的上一条指令计算结果，移入到v1寄存器中（需要配合invoke-static、invoke-virtual等指令使用）</td></tr><tr><td>move-result-object v1</td><td>将上条计算结果的对象指针移入v1寄存器</td></tr><tr><td>move-result-wide v1</td><td>将上条计算结果（双字）的对象指针移入v1寄存器</td></tr><tr><td>move-exception v1</td><td>将异常移入v1寄存器，用于捕获try-catch语句中的异常</td></tr></tbody></table><h2 id="返回操作"><a href="#返回操作" class="headerlink" title="返回操作"></a>返回操作</h2><table><thead><tr><th>代码</th><th>描述</th></tr></thead><tbody><tr><td>return-void</td><td>返回void，即直接返回</td></tr><tr><td>return v1</td><td>返回v1寄存器中的值</td></tr><tr><td>return-object v1</td><td>返回v1寄存器中的对象指针</td></tr><tr><td>return-wide v1</td><td>返回双字型结果给v1寄存器</td></tr></tbody></table><h2 id="常量操作"><a href="#常量操作" class="headerlink" title="常量操作"></a>常量操作</h2><table><thead><tr><th>代码</th><th>描述</th></tr></thead><tbody><tr><td>const(/4、/16、/hight16) v1 xxx</td><td>将常量xxx赋值给v1寄存器，/后的类型，需要根据xxx的长度选择</td></tr><tr><td>const-wide(/16、/32、/hight16) v1 xxx</td><td>将双字型常量xxx赋值给v1寄存器，/后的类型，需要根据xxx的长度选择</td></tr><tr><td>const-string(/jumbo) v1 “aaa”</td><td>将字符串常量”aaa”赋给v1寄存器，过长时需要加上jumbo</td></tr><tr><td>const-class v1 La/b/TargetClass</td><td>将Class常量a.b.TargetClass赋值给v1，等价于a.b.TargetClass.class</td></tr></tbody></table><h2 id="调用操作"><a href="#调用操作" class="headerlink" title="调用操作"></a>调用操作</h2><p>用于调用方法，基本格式：<code>invoke-kind {vC, vD, vE, vF, vG}, meth@BBBB</code>，其中，BBBB代表方法引用（参见上面介绍的方法定义及调用），vC~G为需要的参数，根据顺序一一对应</p><table><thead><tr><th>代码</th><th>描述</th></tr></thead><tbody><tr><td>invoke-virtual</td><td>用于调用一般的，非private、非static、非final、非构造函数的方法，它的第一个参数往往会传p0，也就是this指针</td></tr><tr><td>invoke-super</td><td>用于调用父类中的方法，其他和invoke-virtual保持一致</td></tr><tr><td>invoke-direct</td><td>用于调用private修饰的方法，或者构造方法</td></tr><tr><td>invoke-static</td><td>用于调用静态方法，比如一些工具类</td></tr><tr><td>invoke-interface</td><td>用于调用interface中的方法</td></tr></tbody></table><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>一个Smali文件对应的是一个Java的类，更准确的说是一个.class文件，如果有内部类，需要写成<code>ClassName$InnerClassA</code>、<code>ClassName$InnerClassB</code>…这样的形式</p><h2 id="方法声明及调用"><a href="#方法声明及调用" class="headerlink" title="方法声明及调用"></a>方法声明及调用</h2><p>官方Wiki中给出的Smali引用方法的模板如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Lpackage&#x2F;name&#x2F;ObjectName;-&gt;MethodName(III)Z</span><br></pre></td></tr></table></figure><p>第一部分<code>Lpackage/name/ObjectName;</code>用于声明具体的类型，以便JVM寻找</p><p>第二部分<code>MethodName(III)Z</code>，其中MethodName为具体的方法名，<code>()</code>中的字符，表示了参数数量和类型，即3个int型参数，Z为返回值的类型，即返回Boolean类型</p><p>由于方法的参数列表没有使用逗号这样的分隔符进行划分，所以只能从左到右，根据类型定义来区分参数个数，这一点需要比较仔细来观察</p><p>如果需要调用构造方法，则MethodName为：<code>&lt;init&gt;</code></p><h2 id="寄存器声明及使用"><a href="#寄存器声明及使用" class="headerlink" title="寄存器声明及使用"></a>寄存器声明及使用</h2><p>在Smali中，如果需要存储变量，必须先声明足够数量的寄存器，1个寄存器可以存储32位长度的类型，比如Int，而两个寄存器可以存储64位长度类型的数据，比如Long或Double</p><p>声明可使用的寄存器数量的方式为：<code>.registers N</code>，N代表需要的寄存器的总个数，同时，还有一个关键字<code>.locals</code>，它用于声明非参数的寄存器个数（包含在registers声明的个数当中），也叫做本地寄存器，只在一个方法内有效，但不常用，一般使用registers即可</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.method private test(I)V</span><br><span class="line">    .registers 4  # 声明总共需要使用4个寄存器</span><br><span class="line"></span><br><span class="line">    const-string v0, &quot;LOG&quot;  # 将v0寄存器赋值为字符串常量&quot;LOG&quot;</span><br><span class="line"></span><br><span class="line">    move v1, p1  # 将int型参数的值赋给v1寄存器</span><br><span class="line"></span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><p>结合Dalvik常用的指令进行操作，即可实现一些需要的功能</p><h3 id="那么，如何确定需要使用的寄存器的个数？"><a href="#那么，如何确定需要使用的寄存器的个数？" class="headerlink" title="那么，如何确定需要使用的寄存器的个数？"></a>那么，如何确定需要使用的寄存器的个数？</h3><p>由于非static方法，需要占用一个寄存器以保存this指针，那么这类方法的寄存器个数，最低就为1，如果还需要处理传入的参数，则需要再次叠加，此时还需要考虑Double和Float这种需要占用两个寄存器的参数类型，举例来看：</p><p>如果一个Java方法声明如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myMethod(int p1, float p2, boolean p3)</span><br></pre></td></tr></table></figure><p>那么对应的Smali则为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">method LMyObject;-&gt;myMethod(IJZ)V</span><br></pre></td></tr></table></figure><p>此时，寄存器的对应情况如下：</p><table><thead><tr><th>寄存器名称</th><th>对应的引用</th></tr></thead><tbody><tr><td>p0</td><td>this</td></tr><tr><td>p1</td><td>int型的p1参数</td></tr><tr><td>p2, p3</td><td>float型的p2参数</td></tr><tr><td>p4</td><td>boolean型的p3参数</td></tr></tbody></table><p>那么最少需要的寄存器个数则为：5</p><p>如果方法体内含有常量、变量等定义，则需要根据情况增加寄存器个数，数量只要满足需求，保证需要获取的值不被后面的赋值冲掉即可，方法有：存入类中的字段中（存入后，寄存器可被重新赋值），或者长期占用一个寄存器</p><h2 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h2><p>属性操作的分为：取值（get）和赋值（put）</p><p>目标类型分为：数组（array）、实例（instance）和静态（static）三种，对应的缩写前缀就是a、i、s</p><p>长度类型分为：默认（什么都不写）、<code>wide</code>（宽，64位）、<code>object</code>（对象）、<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>（后面几种就不解释了，和Java一致）</p><p>指令格式：<code>[指令名] [源寄存器], [目标字段所在对象寄存器], [字段指针]</code>，示例代码如下，操作是为int型的类成员变量<code>mIntA</code>赋值为<code>100</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const&#x2F;16 v0, 0x64</span><br><span class="line"></span><br><span class="line">iput v0, p0, Lcom&#x2F;coderyuan&#x2F;smali&#x2F;MainActivity;-&gt;mIntA:I</span><br></pre></td></tr></table></figure><p>下面列出用于实例字段的指令，其中i都可以换成a或者s，分别用于操作数组字段或者静态字段</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>iget</td><td>取值，用于操作int这种的值类型</td></tr><tr><td>iget-wide</td><td>取值，用于操作wide型字段</td></tr><tr><td>iget-object</td><td>取值，用于操作对象引用</td></tr><tr><td>iget-boolean</td><td>取值，用于操作布尔类型</td></tr><tr><td>iget-byte</td><td></td></tr><tr><td>iget-char</td><td>取值，用于操作字符类型</td></tr><tr><td>iget-short</td><td>取值，用于操作short类型</td></tr><tr><td>iput</td><td>赋值，用于操作int这种的值类型</td></tr><tr><td>iput-wide</td><td>赋值，用于操作wide型字段</td></tr><tr><td>iput-object</td><td>赋值，用于操作对象引用</td></tr><tr><td>iput-boolean</td><td>赋值，用于操作布尔类型</td></tr><tr><td>iput-byte</td><td>赋值，用于操作字节类型</td></tr><tr><td>iput-char</td><td>赋值，用于操作字符类型</td></tr><tr><td>iput-short</td><td>赋值，用于操作short类型</td></tr></tbody></table><p>举例：<br>以下Java代码是进行的是最基本的类成员变量的赋值、取值操作</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private String mStringA;</span><br><span class="line">    private int mIntA;</span><br><span class="line">    private Activity mActivityA;</span><br><span class="line"></span><br><span class="line">    public void fieldTest() &#123;</span><br><span class="line">        mStringA &#x3D; &quot;Put String to mStringA&quot;;</span><br><span class="line">        mIntA &#x3D; 100;</span><br><span class="line">        mActivityA &#x3D; this;</span><br><span class="line"></span><br><span class="line">        int len &#x3D; mStringA.length();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对应的Smali代码如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># instance fields</span><br><span class="line">.field private mActivityA:Landroid&#x2F;app&#x2F;Activity;</span><br><span class="line"></span><br><span class="line">.field private mIntA:I</span><br><span class="line"></span><br><span class="line">.field private mStringA:Ljava&#x2F;lang&#x2F;String;</span><br><span class="line"></span><br><span class="line"># virtual methods</span><br><span class="line">.method public fieldTest()V</span><br><span class="line">    .registers 2</span><br><span class="line"></span><br><span class="line">    .line 55</span><br><span class="line">    const-string v0, &quot;Put String to mStringA&quot;</span><br><span class="line"></span><br><span class="line">    iput-object v0, p0, Lcom&#x2F;coderyuan&#x2F;smali&#x2F;MainActivity;-&gt;mStringA:Ljava&#x2F;lang&#x2F;String;</span><br><span class="line"></span><br><span class="line">    .line 56</span><br><span class="line">    const&#x2F;16 v0, 0x64</span><br><span class="line"></span><br><span class="line">    iput v0, p0, Lcom&#x2F;coderyuan&#x2F;smali&#x2F;MainActivity;-&gt;mIntA:I</span><br><span class="line"></span><br><span class="line">    .line 57</span><br><span class="line">    iput-object p0, p0, Lcom&#x2F;coderyuan&#x2F;smali&#x2F;MainActivity;-&gt;mActivityA:Landroid&#x2F;app&#x2F;Activity;</span><br><span class="line"></span><br><span class="line">    .line 59</span><br><span class="line">    iget-object v0, p0, Lcom&#x2F;coderyuan&#x2F;smali&#x2F;MainActivity;-&gt;mStringA:Ljava&#x2F;lang&#x2F;String;</span><br><span class="line"></span><br><span class="line">    invoke-virtual &#123;v0&#125;, Ljava&#x2F;lang&#x2F;String;-&gt;length()I</span><br><span class="line"></span><br><span class="line">    move-result v0</span><br><span class="line"></span><br><span class="line">    .line 60</span><br><span class="line">    .local v0, &quot;len&quot;:I</span><br><span class="line">    return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><p>根据Java和Smali代码的对比，值得注意的是，Smali获取类成员变量的方法，比较接近函数调用，只不过没有函数调用时的参数</p><h2 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h2><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>add-int/lit8 v1, v2, 0x1</td><td>给v2寄存器+1，并存入v1寄存器（注意：lit8是对要加的常量的长度限制，如果不写，则为4位，还可选择lit16，即16位）</td></tr><tr><td>add-int/2addr v1, v2</td><td>将v1、v2寄存器中的值相加，并赋值给v1寄存器</td></tr><tr><td>float-to-int v1, v2</td><td>将v2寄存器中的float类型值转换为int类型，并赋值给v1寄存器</td></tr></tbody></table><p>转载自：<a href="https://coderyuan.com/" target="_blank" rel="noopener" title="袁国正">袁国正</a></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>Laravel框架下的网站优化建议</title>
    <url>/passages/5/</url>
    <content><![CDATA[<!-- build time:Sat Apr 04 2020 13:08:48 GMT+0800 (GMT+08:00) --><p>Laravel是一个功能强大的框架，组件很多，代码也很庞大，它的易用方便是以牺牲性能为前提的，即便如此它仍然是一个优秀、主流的框架，但在正式环境下还要做好优化提升网站的运行速度。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Laravel是一个功能强大的框架，组件很多，代码也很庞大，它的易用方便是以牺牲性能为前提的，即便如此它仍然是一个优秀、主流的框架，但在正式环境下还要做好优化提升网站的运行速度。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><ol><li><p>composer优化</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo composer dump-autoload optimize</span><br></pre></td></tr></table></figure></li><li><p>Laravel优化</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php artisan optimize</span><br></pre></td></tr></table></figure></li><li><p>缓存路由和配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php artisan route:cache</span><br><span class="line">php artisan config:cache</span><br></pre></td></tr></table></figure></li><li><p>关闭debug</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">APP_ENV&#x3D;local</span><br><span class="line">APP_DEBUG&#x3D;false</span><br><span class="line">APP_KEY&#x3D;base64:sT&#x2F;aTFeaE13eyao1Raee6jC9Ff+Yle1SE+wtyk0H6B4&#x3D;</span><br></pre></td></tr></table></figure></li><li><p>使用CDN</p><p>使用CDN是最直接了当，且大众有效的方法</p></li><li><p>nginx开启gzip压缩</p><p>这不仅仅是针对Laravel网站的性能优化方法，其中很多是通用的网站性能优化的方法，当然还有很多可以优化的地方。</p></li><li><p>使用PHP 7并开启OPcache</p><p>开启Opcode cache 之目的是避免重复编译，减少 CPU 和内存开销。</p></li></ol><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>可以把以上提到的优化命令写成一个脚本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env bash</span><br><span class="line">php artisan clear-compiled</span><br><span class="line">php artisan cache:clear</span><br><span class="line">php artisan route:cache</span><br><span class="line">php artisan config:cache</span><br><span class="line">php artisan optimize --force</span><br><span class="line">composer dump-autoload --optimize</span><br><span class="line">chmod -R 777 storage</span><br><span class="line">chmod -R 777 bootstrap&#x2F;cache</span><br></pre></td></tr></table></figure><p>命名为 optimize.sh 放网站根目录，这样可以更加方便执行。</p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Hexo-local-admin不支持在线markdown编辑器问题❓</title>
    <url>/passages/4/</url>
    <content><![CDATA[<!-- build time:Sat Apr 04 2020 13:08:48 GMT+0800 (GMT+08:00) --><p>前面提到用 Hexo-local-admin 使 Hexo 的管理可视化，但使用一段时间后发现，Hexo-local-admin 不支持 mrakdown 在线编辑的缺点实在令人头疼…</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面提到用 Hexo-local-admin 使 Hexo 的管理可视化，但使用一段时间后发现，Hexo-local-admin 不支持 mrakdown 在线编辑的缺点实在令人头疼，今天逛 gitee 的时候找到一款 Markdown 前端编辑器。刚好解决了我管理博客的又一难题。😃📈</p><p>Editor.md 详情点击 👉：<a href="http://editor.md.ipandao.com/" target="_blank" rel="noopener">http://editor.md.ipandao.com/</a></p><h2 id="预览截图"><a href="#预览截图" class="headerlink" title="预览截图"></a>预览截图</h2><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Aunger-ops/myblog@latest/images/2020/04/1.png" alt="截图专用" title="截图专用"></p><h2 id="HOW-TO-USE"><a href="#HOW-TO-USE" class="headerlink" title="HOW-TO-USE"></a>HOW-TO-USE</h2><ol><li><p>到Hexo-Local-admin根目录 npm 安装：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install editor.md</span><br></pre></td></tr></table></figure></li><li><p>找到你计算机 nodejs 安装位置，找到</p><p><code>\node_modules\hexo-local-admin\views\ejs\tpl\new-post.ejs</code></p></li><li><p>将以下代码</p></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;textarea name&#x3D;&quot;content&quot; id&#x3D;&quot;content-editor&quot;&gt;---</span><br><span class="line">title: new post</span><br><span class="line">date: &quot;&lt;%&#x3D; time %&gt;&quot;</span><br><span class="line">---</span><br><span class="line">new content here&lt;&#x2F;textarea&gt;</span><br></pre></td></tr></table></figure><ul><li>前后追加<br>前：<code>&lt;div id=&quot;test-editor&quot;&gt;</code><br>后：<code>&lt;/div&gt;</code></li><li>找到 <code>views\public\js\entry.min.js</code><br>加入函数<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(function() &#123;</span><br><span class="line">       var editor &#x3D; editormd(&quot;test-editor&quot;, &#123;</span><br><span class="line">            width  : &quot;100%&quot;,</span><br><span class="line">            height : &quot;500px&quot;,</span><br><span class="line">           path   : &quot;editormd&#x2F;lib&#x2F;&quot;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure><ul><li>找到<code>views\public\ejs\index.ejs</code><br>在head标签处加入<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;/editormd/css/editormd.css&quot; /&gt;</code><br>在footer处加入<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;1.11.3&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;editormd&#x2F;editormd.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li>将下载解压来的Editor.md文件夹更改为”editormd”，粘贴到hexo-local-admin的<code>views/public</code>下即可.<h2 id="完毕"><a href="#完毕" class="headerlink" title="完毕"></a>完毕</h2></li></ul><p><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Aunger-ops/myblog@latest/images/2020/04/2.png" alt="截图专用" title="截图专用"></p><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
  <entry>
    <title>推荐一款Hexo可视化管理工具🔨</title>
    <url>/passages/3/</url>
    <content><![CDATA[<!-- build time:Sat Apr 04 2020 13:08:48 GMT+0800 (GMT+08:00) --><p>最近把博客系统从 Typecho 转到了 Hexo，但是 Hexo 的命令行写文章在我心头一直是一块硬疙瘩。用了很多可视化管理工具，最终还是认定了 hexo-local-admin。👍</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近把博客系统从 Typecho 转到了 Hexo，但是 Hexo 的命令行写文章在我心头一直是一块硬疙瘩。用了很多可视化管理工具，最终还是认定了 hexo-local-admin。👍</p><h2 id="预览截图"><a href="#预览截图" class="headerlink" title="预览截图"></a>预览截图</h2><table><thead><tr><th align="center"><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Aunger-ops/myblog@latest/images/2020/03/1.png" alt="微信截图_20200107141251.png"></th><th align="center"><img src="/images/loading.gif" data-original="https://cdn.jsdelivr.net/gh/Aunger-ops/myblog@latest/images/2020/03/2.png" alt="微信截图_20200107141251.png"></th></tr></thead></table><h2 id="HOW-TO-USE"><a href="#HOW-TO-USE" class="headerlink" title="HOW-TO-USE"></a>HOW-TO-USE</h2><ol><li>install</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-local-admin</span><br></pre></td></tr></table></figure><ol start="2"><li>use command</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo-admin -h</span><br></pre></td></tr></table></figure><ol start="3"><li>will get:</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: hexo-admin [options] [command]</span><br><span class="line">Commands:</span><br><span class="line">  start   Start hexo local admin server</span><br><span class="line">Options:</span><br><span class="line">    -h, --help                     output usage information</span><br><span class="line">    -V, --version                  output the version number</span><br><span class="line">    -r, --root-path [root_path]    view&#x2F;set hexo root path</span><br><span class="line">    -t, --theme-name [theme_name]  view&#x2F;set hexo theme name</span><br></pre></td></tr></table></figure><ol start="4"><li>enjoy!</li></ol><!-- rebuild by neat -->]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
  </entry>
</search>
